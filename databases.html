<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Databases | CS-499 Portfolio</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header>
    <h1>Databases</h1>
    <nav>
      <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="software.html">Software Design & Engineering</a></li>
        <li><a href="algorithms.html">Algorithms & Data Structures</a></li>
        <li><a href="databases.html">Databases</a></li>
        <li><a href="code-review.html">Code Review Video</a></li>
      </ul>
    </nav>
  </header>

  <main>
    <section>
      <h2>Artifact Overview</h2>
      <p>
        This enhancement focused on integrating a robust and persistent logging system into HELIOS using SQLite.
        Prior to this, request data was held only in memory or appended loosely to text files. The database system ensures structured storage and powerful querying capabilities.
      </p>
    </section>

    <section>
      <h2>Project Background</h2>
      <p>
        Persistent data logging is crucial for any real-world application. For HELIOS, having an auditable and queryable request log would allow me to track usage patterns, detect errors, and audit system events.
        I chose SQLite due to its ease of deployment and zero-maintenance requirements.
      </p>
    </section>

    <section>
      <h2>Enhancement Highlights</h2>
      <ul>
        <li>Created a SQLite database schema to store media request logs</li>
        <li>Wrote controller methods to handle insert queries</li>
        <li>Implemented SQLite query functions to manually test real-world database interactions</li>
        <li>Validated query logic using `sqlite3` CLI and Python</li>
      </ul>
    </section>

    <section>
      <h2>Preview the Code</h2>
      <p>Below is a snippet of the logging logic written in Python to insert information into both the memory queue and the SQLite database without breaking the existing flow or introducing latency or redundancy:</p>
      <pre><code class="language-py">
import sqlite3

def log_request_to_db(title, timestamp):
    connection = sqlite3.connect("helios_logs.db")
    cursor = connection.cursor()
    cursor.execute("INSERT INTO requests (title, timestamp) VALUES (?, ?)", (title, timestamp))
    connection.commit()
    connection.close()
      </code></pre>
    </section>

    <section>
      <h2>Database Schema</h2>
      <pre><code class="language-sql">
CREATE TABLE requests (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title TEXT NOT NULL,
  timestamp TEXT NOT NULL
);
      </code></pre>
    </section>

    <section>
      <h2>Download / View Files</h2>
      <ul>
        <li><a href="artifacts/helios_request_logger.zip" download>Download: helios_request_logger.zip</a></li>
        <li><a href="artifacts/Helios_Capstone_Enhancement_SoftwareEngineering.zip" download>Final Project Archive (.zip)</a></li>
      </ul>
    </section>

    <section>
      <h2>Reflection</h2>
      <p>
        Implementing a persistent data layer with SQLite was a transformative enhancement. It pushed me to think about data structure integrity, security, and future scalability.
        The database integration supports debugging, analytics, and observability for long-term system maintenance.
      </p>
    </section>
  </main>

  <footer>
    <p>&copy; 2025 Frank Inscoe | <a href="mailto:finscoe@gmail.com">Contact Me</a></p>
  </footer>
</body>
</html>
