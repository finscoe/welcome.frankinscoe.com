<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Algorithms & Data Structures | CS-499 Portfolio</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header>
    <h1>Algorithms & Data Structures</h1>
    <nav>
      <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="software.html">Software Design & Engineering</a></li>
        <li><a href="algorithms.html">Algorithms & Data Structures</a></li>
        <li><a href="databases.html">Databases</a></li>
        <li><a href="code-review.html">Code Review Video</a></li>
      </ul>
    </nav>
  </header>

  <main>
    <section>
      <h2>Artifact Overview</h2>
      <p>
        This enhancement involved implementing an optimized request queue to manage asynchronous media downloads
        for the HELIOS project. Using Python, I created a `MediaRequestQueue` class that applies fundamental data structure principles
        to ensure orderly processing, duplication prevention, and efficient memory usage.
      </p>
    </section>

    <section>
      <h2>Project Background</h2>
      <p>
        The HELIOS system receives many automated media requests from integrated services like Sonarr and Radarr.
        Prior to this enhancement, requests were unstructured and vulnerable to duplication or overflow. To improve the reliability of this system,
        I implemented a FIFO-style queue with a configurable maximum size and safety checks.
      </p>
    </section>

    <section>
      <h2>Enhancement Highlights</h2>
      <ul>
        <li>Created a reusable and testable Python class to manage media requests</li>
        <li>Implemented safe enqueuing, deduplication, and peek methods</li>
        <li>Added basic queue size limit enforcement to prevent memory overrun</li>
        <li>Wrote unit tests to verify queue behavior across different usage scenarios</li>
      </ul>
    </section>

    <section>
      <h2>Preview the Code</h2>
      <p>Below is a snippet from the custom request queue class:</p>
      <pre><code class="language-py">
class MediaRequestQueue:
    def __init__(self, max_size=50):
        self.queue = []
        self.max_size = max_size

    def enqueue(self, request):
        if request not in self.queue and len(self.queue) < self.max_size:
            self.queue.append(request)

    def dequeue(self):
        if self.queue:
            return self.queue.pop(0)
        return None

    def peek(self):
        return self.queue[0] if self.queue else None
      </code></pre>
    </section>

    <section>
      <h2>Download / View Files</h2>
      <ul>
        <li><a href="artifacts/media_request_queue.py" download>Download media_request_queue.py</a></li>
        <li><a href="artifacts/helios_request_logger.zip" download>Download HELIOS request_logger.zip</a></li>
      </ul>
    </section>

    <section>
      <h2>Reflection</h2>
      <p>
        This enhancement reinforced my understanding of how abstract data structures translate into real-world functionality.
        Managing asynchronous workflows with a queue helped reduce system errors and laid the foundation for more advanced
        request processing features in the future.
      </p>
    </section>
  </main>

  <footer>
    <p>&copy; 2025 Frank Inscoe | <a href="mailto:finscoe@gmail.com">Contact Me</a></p>
  </footer>
</body>
</html>
